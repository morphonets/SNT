/*-
 * #%L
 * Fiji distribution of ImageJ for the life sciences.
 * %%
 * Copyright (C) 2010 - 2024 Fiji developers.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

package sc.fiji.snt;

import ij.ImagePlus;
import ij.measure.Calibration;
import ij3d.Content;
import ij3d.Image3DUniverse;
import ij3d.Pipe;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.analysis.interpolation.LinearInterpolator;
import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction;
import org.apache.commons.math3.stat.StatUtils;
import org.scijava.util.ColorRGB;
import org.scijava.util.ColorRGBA;
import org.scijava.vecmath.Color3f;
import org.scijava.vecmath.Point3f;
import sc.fiji.snt.analysis.PathProfiler;
import sc.fiji.snt.annotation.BrainAnnotation;
import sc.fiji.snt.gui.GuiUtils;
import sc.fiji.snt.hyperpanes.MultiDThreePanes;
import sc.fiji.snt.util.*;

import java.awt.*;
import java.util.List;
import java.util.function.DoublePredicate;
import java.util.*;
import java.util.stream.DoubleStream;

/**
 * This class represents a traced segment (i.e., a <i>Path</i>) in a
 * reconstruction. It has methods to manipulate its points (nodes) with
 * sup-pixel accuracy, including drawing them onto threePane-style canvases,
 * etc.
 * <p>
 * Paths are non-branching sequences of adjacent points (including diagonals) in
 * the image. Branches and joins are supported by attributes of paths that
 * specify that they begin on (or end on) other paths.
 * </p>
 * <p>
 * In SNT, a Path can exist in two versions or flavors: itself and a fitted
 * version generated by {@link PathFitter}. Because fitting may fail around
 * certain nodes, the fitted version may have a different number of nodes
 * relatively to its unfitted version
 * </p>
 **/
public class Path implements Comparable<Path> {

	static { net.imagej.patcher.LegacyInjector.preinit(); } // required for _every_ class that imports ij. classes

	// https://swc-specification.readthedocs.io/en/latest/
	
	/** SWC type flag specifying {@value #SWC_UNDEFINED_LABEL} */
	public static final int SWC_UNDEFINED = 0;
	/** SWC type flag specifying {@value #SWC_SOMA_LABEL} */
	public static final int SWC_SOMA = 1;
	/** SWC type flag specifying {@value #SWC_AXON_LABEL} */
	public static final int SWC_AXON = 2;
	/** SWC type flag specifying {@value #SWC_DENDRITE_LABEL} */
	public static final int SWC_DENDRITE = 3;
	/** SWC type flag specifying {@value #SWC_APICAL_DENDRITE_LABEL} */
	public static final int SWC_APICAL_DENDRITE = 4;
	/** SWC type flag specifying {@value #SWC_CUSTOM_LABEL} */
	public static final int SWC_CUSTOM = 5;
	/** SWC type flag specifying {@value #SWC_UNSPECIFIED_LABEL} */
	public static final int SWC_UNSPECIFIED = 6;
	/** SWC type flag specifying {@value #SWC_GLIA_LABEL} */
	public static final int SWC_GLIA_PROCESS = 7;
	/** SWC type flag specifying {@value #SWC_CUSTOM2_LABEL} */
	public static final int SWC_CUSTOM2 = 8;

	/** Deprecated. No longer part of the SWC specification */
	@Deprecated
	public static final int SWC_FORK_POINT = -5;
	/** Deprecated. No longer part of the SWC specification */
	@Deprecated
	public static final int SWC_END_POINT = -6;
	
	/** String representation of {@link Path#SWC_UNDEFINED} */
	public static final String SWC_UNDEFINED_LABEL = "undefined";
	/** String representation of {@link Path#SWC_SOMA} */
	public static final String SWC_SOMA_LABEL = "soma";
	/** String representation of {@link Path#SWC_AXON} */
	public static final String SWC_AXON_LABEL = "axon";
	/** String representation of {@link Path#SWC_DENDRITE} */
	public static final String SWC_DENDRITE_LABEL = "(basal) dendrite";
	/** String representation of {@link Path#SWC_APICAL_DENDRITE} */
	public static final String SWC_APICAL_DENDRITE_LABEL = "apical dendrite";
	/** String representation of {@link Path#SWC_CUSTOM} */
	public static final String SWC_CUSTOM_LABEL = "custom";
	/** String representation of {@link Path#SWC_UNSPECIFIED} */
	public static final String SWC_UNSPECIFIED_LABEL = "unspecified neurite";
	/** String representation of {@link Path#SWC_GLIA_PROCESS} */
	public static final String SWC_GLIA_PROCESS_LABEL = "glia process";
	/** String representation of {@link Path#SWC_CUSTOM2} */
	public static final String SWC_CUSTOM2_LABEL = "custom (2)";

	// FIXME: this should be based on distance between points in the path, not a static number:
	protected static final int noMoreThanOneEvery = 2;

	/* Path properties */
	// n. of nodes
	private int points;
	// node coordinates
	protected double[] precise_x_positions;
	protected double[] precise_y_positions;
	protected double[] precise_z_positions;
	// radii and tangents
	protected double[] radii;
	protected double[] tangents_x;
	protected double[] tangents_y;
	protected double[] tangents_z;
	// numeric properties of nodes (e.g., pixel intensities)
	private double[] nodeValues;
	// BrainAnnotations associated with this node;
	private BrainAnnotation[] nodeAnnotations;
	// Hemisphere flags associated with this node;
	private char[] nodeHemisphereFlags;
	/*
	 * Path identifiers: this Path's id is stored in (lower) bits 15-0. Tree id in
	 * the (upper) bits 31-16. NB: should only be assigned by PathAndFillManager.
	 * NB: A regular path should have a path ID > 0, because if present, its fitted
	 * version will have an ID of -path ID. see {@link #setFitted(Path)}
	 */
	private long id = -1L;
	private String treeLabel;

	// NB: The leagacy 3D viewer requires always a unique name
	private String name;
	// Path based ordering akin of reverse Horton-Strahler numbers
	private int order = 1;
	// The SWC-type flag of this path
	int swcType = SWC_UNDEFINED;
	// is this path selected in the UI?
	private boolean selected;
	// the node being edited when in 'Analysis mode'
	private int editableNodeIndex = -1;
	// whether node being edited is locked
	private boolean editableNodeLocked;

	// the display offset for this Path in a tracing canvas
	protected PointInCanvas canvasOffset = new PointInCanvas(0, 0, 0);

	// the channel and frame associated with this Path (1-based indices)
	private final int[] ctPosition;
	// the number of spines or varicosities associated with this path
	private int spinesOrVaricosities;

	/* Spatial calibration definitions */
	protected double x_spacing;
	protected double y_spacing;
	protected double z_spacing;
	protected String spacing_units;

	/* Branching */
	protected Path startJoins;
	protected PointInImage startJoinsPoint = null;
	// This is a symmetrical relationship, showing
	// all the other paths this one is joined to...
	protected ArrayList<Path> somehowJoins;
	// We sometimes impose a tree structure on the Path
	// graph, which is largely for display purposes. When
	// this is done, we regerated this list. This should
	// always be a subset of 'somehowJoins'...
	protected ArrayList<Path> children;

	/* Fitting (Path refinement) */
	// If this path has a fitted version, this is it
	protected Path fitted;
	// Prefer the fitted flavor of this path
	private boolean useFitted;
	// If this path is a fitted version of another one, this is the original
	protected Path fittedVersionOf;

	/* Color definitions */
	private Color color;
	private Color3f realColor;
	private boolean hasCustomColor;
	private Color[] nodeColors;

	/* Internal fields */
	private int maxPoints;

	private final List<PathChangeListener> changeListeners;


	/**
	 * Instantiates a new path under default settings (isotropic 1um pixel spacing)
	 */
	public Path() {
		this(1, 1, 1, GuiUtils.micrometer());
	}

	/**
	 * Instantiates a new path.
	 *
	 * @param x_spacing Pixel width in spacing_units
	 * @param y_spacing Pixel height in spacing_units
	 * @param z_spacing Pixel depth in spacing_units
	 * @param spacing_units the length unit in physical world units (typically
	 *          "um").
	 */
	public Path(final double x_spacing, final double y_spacing,
		final double z_spacing, final String spacing_units)
	{
		this(x_spacing, y_spacing, z_spacing, spacing_units, 128);
	}

	Path(final double x_spacing, final double y_spacing, final double z_spacing,
		final String spacing_units, final int reserve)
	{
		this.x_spacing = x_spacing;
		this.y_spacing = y_spacing;
		this.z_spacing = z_spacing;
		this.spacing_units = SNTUtils.getSanitizedUnit(spacing_units);
		points = 0;
		maxPoints = reserve;
		precise_x_positions = new double[maxPoints];
		precise_y_positions = new double[maxPoints];
		precise_z_positions = new double[maxPoints];
		somehowJoins = new ArrayList<>();
		children = new ArrayList<>();
		ctPosition = new int[] {1, 1};
		changeListeners = new ArrayList<>();
	}

	/* (non-Javadoc)
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(final Path o) {
		return Long.compare(id, o.id);
	}

	/**
	 * Gets the identifier of this Path
	 *
	 * @return the identifier
	 */
	public int getID() {
		return (int) id; // (lower) bits 15-0
	}

	/**
	 * Gets the identifier of the {@link Tree} associated to this Path (if any).
	 *
	 * @return the Tree identifier
	 */
	public int getTreeID() {
		return (int) (id >> 32); // (upper) bits 31-16
	}

	protected void setIDs(final int pathID, final int treeID) {
		final int oldId = getID();
		// pathID to fill lower bits, treeID to fill upper bits
		id = (((long) treeID) << 32) | (pathID & 0xffffffffL);
		changeListeners.forEach(l -> l.pathChanged(
				new PathChangeEvent(this, PathChangeEvent.EventType.ID_CHANGED, oldId, getID())));
	}

	protected void setTreeLabel(final String treeLabel) {
		this.treeLabel = treeLabel;
		if (getFitted() != null) getFitted().setTreeLabel(treeLabel); 
	}

	public String getTreeLabel() {
		if (isFittedVersionOfAnotherPath()) {
			return fittedVersionOf.getTreeLabel();
		}
		return (treeLabel == null) ? "Cell " + getTreeID() : treeLabel;
	}

	/**
	 * Specifies a translation offset when rendering this Path in a
	 * {@link TracerCanvas}. Path coordinates remain unaltered.
	 *
	 * @param canvasOffset the x,y,z coordinates (pixel-based) specifying the
	 *          translation offset
	 */
	public void setCanvasOffset(final PointInCanvas canvasOffset) {
		this.canvasOffset = canvasOffset;
		if (getFitted() != null) getFitted().setCanvasOffset(canvasOffset);
	}

	/**
	 * Returns the translation offset used to render this Path in a
	 * {@link TracerCanvas}.
	 *
	 * @return the rendering offset (in pixel coordinates)
	 */
	public PointInCanvas getCanvasOffset() {
		canvasOffset.onPath = this;
		return canvasOffset;
	}

	public Path getStartJoins() {
		return startJoins;
	}

	public PointInImage getStartJoinsPoint() { // TODO: this should be renamed?
		return startJoinsPoint;
	}

	/**
	 * Sets this Path's name. Set it to null or {@code ""}, to reset it to the
	 * default.
	 *
	 * @param newName the new name.
	 * @see #getName()
	 */
	public void setName(final String newName) {
		final String oldName =  getName();
		this.name = newName;
		getName(); // assign default if newName is null
		changeListeners.forEach(l -> l.pathChanged(
				new PathChangeEvent(this, PathChangeEvent.EventType.NAME_CHANGED, oldName, getName())));
	}

	/**
	 * Gets this Path's name.
	 *
	 * @return the name. If no name as been set, the default name is returned.
	 * @see #setName(String)
	 */
	public String getName() {
		if (name == null || name.isEmpty()) name = "Path " + getID();
		return name;
	}

	protected static String pathsToIDListString(final ArrayList<Path> a) {
		final StringBuilder s = new StringBuilder();
		final int n = a.size();
		for (int i = 0; i < n; ++i) {
			s.append(a.get(i).getID());
			if (i < n - 1) {
				s.append(",");
			}
		}
		return s.toString();
	}

	protected String somehowJoinsAsString() {
		return pathsToIDListString(somehowJoins);
	}

	protected String childrenAsString() {
		return pathsToIDListString(children);
	}

	protected void setChildren(final Set<Path> pathsLeft) {
		// Set the children of this path in a breadth first fashion:
		children.clear();
		for (final Path c : somehowJoins) {
			if (pathsLeft.contains(c)) {
				children.add(c);
				pathsLeft.remove(c);
			}
		}
		for (final Path c : children)
			c.setChildren(pathsLeft);
	}

	/**
	 * Returns the ratio between the "Euclidean distance" of this path and its
	 * length. The Euclidean distance of this path is defined as the distance
	 * between this Path's start and end point.
	 *
	 * @return the Contraction of this Path, or {@code NaN} if this Path has no length
	 */
	public double getContraction() {
		final double length = getLength();
		if (length == 0) return Double.NaN;
		final double eDistance = getNode(size() - 1).distanceTo(getNode(0));
		return eDistance / length;
	}

	/**
	 * Gets the length of this Path
	 *
	 * @return the length of this Path
	 */
	public double getLength() {
		double totalLength = 0;
		for (int i = 1; i < points; ++i) {
			final double xdiff = precise_x_positions[i] - precise_x_positions[i - 1];
			final double ydiff = precise_y_positions[i] - precise_y_positions[i - 1];
			final double zdiff = precise_z_positions[i] - precise_z_positions[i - 1];
			totalLength += Math.sqrt(xdiff * xdiff + ydiff * ydiff + zdiff * zdiff);
		}
		return totalLength;
	}

	protected String getRealLengthString() {
		return String.format(Locale.US, "%.3f", getLength()); // see https://github.com/morphonets/SNT/issues/147
	}

	public void createCircles() {
//		if (tangents_x != null || tangents_y != null || tangents_z != null ||
//			radii != null) throw new IllegalArgumentException(
//				"Trying to create circles data arrays when at least one is already there");
		if (tangents_x == null)
			tangents_x = new double[maxPoints];
		if (tangents_y == null)
			tangents_y = new double[maxPoints];
		if (tangents_z == null)
			tangents_z = new double[maxPoints];
		if (radii == null)
			radii = new double[maxPoints];
	}

	protected void setIsPrimary(final boolean primary) {
		if (primary) setOrder(1);
	}

	/**
	 * Checks if this Path is root.
	 *
	 * @return true, if is primary (root)
	 */
	public boolean isPrimary() {
		return order == 1 || (startJoins == null);
	}

	/*
	 * We call this if we're going to delete the path represented by this object
	 */
	protected void disconnectFromAll() {
		/*
		 * This path can be connected to other ones either if: 1) this starts on other;
		 * 2) other starts on this In any of these cases, we need to also remove this
		 * from other's somehowJoins and other from this's somehowJoins.
		 */
		for (final Path other : somehowJoins) {
			if (other.startJoins == this) {
				other.startJoins = null;
				other.startJoinsPoint = null;
			}
			other.somehowJoins.remove(this);
			other.children.remove(this);
		}
		somehowJoins.clear();
		children.clear();
		startJoins = null;
		startJoinsPoint = null;
		setIsPrimary(true);
	}

	public void setStartJoin(final Path other, final PointInImage joinPoint) {
		if (other == null) {
			throw new IllegalArgumentException(
				"setJoin should never take a null path");
		}
		{
			// If there was an existing path, that's an error:
			if (startJoins != null) throw new IllegalArgumentException(
				"setJoin for START should not replace another join");
			startJoins = other;
			startJoinsPoint = joinPoint;
			startJoinsPoint.onPath = this;
		}
		// Also update the somehowJoins list:
		if (!somehowJoins.contains(other)) {
			somehowJoins.add(other);
		}
		if (!other.somehowJoins.contains(this)) {
			other.somehowJoins.add(this);
		}
		if (!other.children.contains(this)) {
			other.children.add(this);
		}
		// update order
		setOrder(other.order + 1);
	}

	protected void replaceNodesWithFittedVersion() {
		if (fitted == null) {
			throw new IllegalArgumentException("assignFittedNodes() called but path has no fitted flavor");
		}
		points = fitted.points;
		precise_x_positions = fitted.precise_x_positions.clone();
		precise_y_positions = fitted.precise_y_positions.clone();
		precise_z_positions = fitted.precise_z_positions.clone();
		if (fitted.radii != null) radii = fitted.radii.clone();
		if (fitted.tangents_x != null) tangents_x = fitted.tangents_x.clone();
		if (fitted.tangents_y != null) tangents_y = fitted.tangents_y.clone();
		if (fitted.tangents_z != null) tangents_z = fitted.tangents_z.clone();
		if (fitted.nodeValues != null) nodeValues = fitted.nodeValues.clone();
		if (fitted.nodeAnnotations != null) nodeAnnotations = fitted.nodeAnnotations.clone();
		if (fitted.nodeHemisphereFlags != null) nodeHemisphereFlags = fitted.nodeHemisphereFlags.clone();
		setNodeColors(fitted.getNodeColors());
		if (!getName().contains(" [Fitted*]")) setName( getName() + " [Fitted*]");
		if (getStartJoins() != null) {
			final int index = startJoins.indexNearestTo(precise_x_positions[0], precise_y_positions[0], precise_z_positions[0]);
			final PointInImage pim = (index == -1) ? startJoinsPoint : startJoins.getNodeWithoutChecks(index);
			startJoinsPoint.x = pim.x;
			startJoinsPoint.y = pim.y;
			startJoinsPoint.z = pim.z;
		}
		setUseFitted(false);
		fitted = null;
	}

	protected void rebuildConnectionsOfFittedVersion() {
		if (fitted == null)
			return;
		if (getStartJoins() != null) { // this is always the case if not primary
			if (fitted.startJoins != null) fitted.unsetStartJoin();
			if (startJoins.getUseFitted()) {
				final int index = startJoins.fitted.indexNearestTo(startJoinsPoint.x, startJoinsPoint.y, startJoinsPoint.z);
				final PointInImage pim = (index == -1) ? startJoinsPoint : startJoins.fitted.getNodeWithoutChecks(index);
				fitted.setStartJoin(startJoins.getFitted(), pim);
			} else {
				fitted.setStartJoin(startJoins, startJoinsPoint);
			}
		}
	}

	public void unsetStartJoin() {
		Path other = startJoins;
		if (other == null) {
			throw new IllegalArgumentException(
				"Don't call unsetJoin if the other Path is already null");
		}
		if (!(other.startJoins == this))
		{
			somehowJoins.remove(other);
			other.somehowJoins.remove(this);
			other.children.remove(this);
		}
		{
			startJoins = null;
			startJoinsPoint = null;
		}
		setOrder(-1);
	}

	protected double getMinimumSeparation() {
		return Math.min(Math.abs(x_spacing), Math.min(Math.abs(y_spacing), Math.abs(
			z_spacing)));
	}

	/**
	 * Returns the number of nodes of this path
	 *
	 * @return the size, i.e., number of nodes
	 */
	public int size() {
		return points;
	}

	protected void getPointDouble(final int i, final double[] p) {
		if ((i < 0) || i >= size()) {
			throw new IndexOutOfBoundsException(
				"BUG: getPointDouble was asked for an out-of-range point: " + i);
		}

		p[0] = precise_x_positions[i];
		p[1] = precise_y_positions[i];
		p[2] = precise_z_positions[i];
	}

	/**
	 * Gets the node at the specified position.
	 *
	 * @param pos the position index (0-based). NB: You can use -1 to retrieve the
	 *            last node in the Path
	 * @return the node
	 * @throws IndexOutOfBoundsException if position is out-of-range
	 */
	public PointInImage getNode(final int pos) throws IndexOutOfBoundsException {
		if (pos == -1)
			return getNodeWithoutChecks(size()-1);
		if ((pos < 0) || pos >= size()) {
			throw new IndexOutOfBoundsException(
				"getNode() was asked for an out-of-range point: " + pos);
		}
		return getNodeWithoutChecks(pos);
	}

	/**
	 * Gets the nodes of this path.
	 *
	 * @return the list of nodes that form this path
	 */
	public List<PointInImage> getNodes() {
		final List<PointInImage> list = new ArrayList<>(size());
		for (int i = 0; i < size(); i++) {
			list.add(getNodeWithoutChecks(i));
		}
		return list;
	}

	protected PointInImage getNodeWithoutChecks(final int pos) {
		final PointInImage result = new PointInImage(precise_x_positions[pos],
			precise_y_positions[pos], precise_z_positions[pos]);
		result.onPath = this;
		if (nodeValues != null) result.v = nodeValues[pos];
		if (nodeAnnotations != null) result.setAnnotation(nodeAnnotations[pos]);
		if (nodeHemisphereFlags != null) result.setHemisphere(nodeHemisphereFlags[pos]);
		return result;
	}

	public PointInCanvas getPointInCanvas(final int node) {
		final PointInCanvas result = new PointInCanvas(getXUnscaledDouble(node), getYUnscaledDouble(node),
				getZUnscaledDouble(node));
		result.onPath = this;
		return result;
	}

	protected PointInCanvas getPointInCanvas2D(final int node, final TracerCanvas canvas) {
		final PointInCanvas result;
		switch(canvas.getPlane()) {
		case MultiDThreePanes.XZ_PLANE:
			result = new PointInCanvas(getXUnscaledDouble(node), getZUnscaledDouble(node), 0);
			break;
		case MultiDThreePanes.ZY_PLANE:
			result = new PointInCanvas(getZUnscaledDouble(node), getYUnscaledDouble(node), 0);
			break;
		default:
			result = new PointInCanvas(getXUnscaledDouble(node), getYUnscaledDouble(node), 0);
			break;
		}
		result.onPath = this;
		return result;
	}

	protected List<PointInCanvas> getUnscaledNodesInViewPort(final TracerCanvas canvas) {
		final BoundingBox box = canvas.getViewPort();
		final List<PointInCanvas> nodes = new ArrayList<>();
		for (int i = 0; i < size(); i++) {
			final PointInCanvas node = getPointInCanvas2D(i, canvas);
			if (box.contains(node)) nodes.add(node);
		}
		return nodes;
	}

	protected boolean containsUnscaledNodesInViewPort(final TracerCanvas canvas) {
		final BoundingBox box = canvas.getViewPort();
		for (int i = 0; i < size(); i++) {
			final PointInCanvas node = getPointInCanvas2D(i, canvas);
			if (box.contains(node))
				return true;
		}
		return false;
	}

	/**
	 * Check whether this Path contains the specified point
	 *
	 * @param pim the {@link PointInImage} node
	 * @return true, if successful
	 */
	public boolean contains(final PointInImage pim) {
		if (pim.onPath != null) return pim.onPath == this;
		return (DoubleStream.of(precise_x_positions).anyMatch(x -> x == pim.x) &&
			DoubleStream.of(precise_y_positions).anyMatch(y -> y == pim.y) &&
			DoubleStream.of(precise_z_positions).anyMatch(z -> z == pim.z));
	}

	/**
	 * Inserts a node at a specified position.
	 *
	 * @param index the (zero-based) index of the position of the new node
	 * @param point the node to be inserted
	 * @throws IllegalArgumentException if index is out-of-range
	 */
	public void insertNode(final int index, final PointInImage point) {
		if (index < 0 || index > size()) throw new IllegalArgumentException(
			"addNode() asked for an out-of-range point: " + index);

		// FIXME: This all would be much easier if we were using Collections/Lists
		precise_x_positions = ArrayUtils.insert(index, precise_x_positions,
			point.x);
		precise_y_positions = ArrayUtils.insert(index, precise_y_positions,
			point.y);
		precise_z_positions = ArrayUtils.insert(index, precise_z_positions,
			point.z);
		points++;
		if (hasRadii()) {
			tangents_x = ArrayUtils.insert(index, tangents_x, 0d);
			tangents_y = ArrayUtils.insert(index, tangents_y, 0d);
			tangents_z = ArrayUtils.insert(index, tangents_z, 0d);
			radii = ArrayUtils.insert(index, radii, 0d);
		}
		if (nodeAnnotations != null) {
			nodeAnnotations = ArrayUtils.insert(index, nodeAnnotations, (BrainAnnotation)null);
		}
		if (nodeHemisphereFlags != null) {
			nodeHemisphereFlags = ArrayUtils.insert(index, nodeHemisphereFlags, BrainAnnotation.ANY_HEMISPHERE);
		}
		if (nodeValues != null) {
			nodeValues = ArrayUtils.insert(index, nodeValues, Double.NaN);
		}
	}

	/**
	 * Removes the specified node if this path has at least two nodes. Does
	 * nothing if this is a single point path.
	 *
	 * @param index the zero-based index of the node to be removed
	 * @throws IllegalArgumentException if index is out-of-range
	 */
	public void removeNode(final int index) {
		if (points == 1) return;
		if (index < 0 || index >= points) throw new IllegalArgumentException(
			"removeNode() asked for an out-of-range point: " + index);
		// FIXME: This all would be much easier if we were using Collections/Lists
		final PointInImage p = getNodeWithoutChecks(index);
		precise_x_positions = ArrayUtils.remove(precise_x_positions, index);
		precise_y_positions = ArrayUtils.remove(precise_y_positions, index);
		precise_z_positions = ArrayUtils.remove(precise_z_positions, index);
		points -= 1;
		if (hasRadii()) {
			tangents_x = ArrayUtils.remove(tangents_x, index);
			tangents_y = ArrayUtils.remove(tangents_y, index);
			tangents_z = ArrayUtils.remove(tangents_z, index);
			radii = ArrayUtils.remove(radii, index);
		}
		if (nodeAnnotations != null) {
			nodeAnnotations = ArrayUtils.remove(nodeAnnotations, index);
		}
		if (nodeHemisphereFlags != null) {
			nodeHemisphereFlags = ArrayUtils.remove(nodeHemisphereFlags, index);
		}
		if (nodeValues != null) {
			nodeValues = ArrayUtils.remove(nodeValues, index);
		}
		if (p.equals(startJoinsPoint)) startJoinsPoint = getNodeWithoutChecks(0);
	}

	/**
	 * Assigns a new location to the specified node.
	 *
	 * @param index the zero-based index of the node to be modified
	 * @param destination the new node location
	 * @throws IllegalArgumentException if index is out-of-range
	 */
	public void moveNode(final int index, final PointInImage destination) {
		if (index < 0 || index >= size()) throw new IllegalArgumentException(
			"moveNode() asked for an out-of-range point: " + index);
		final PointInImage thisLoc = getNodeWithoutChecks(index);
		precise_x_positions[index] = destination.x;
		precise_y_positions[index] = destination.y;
		precise_z_positions[index] = destination.z;
		// If this is a start join for other paths, update those as well
		for (final Path p : somehowJoins) {
			final PointInImage startJoinsPoint = p.getStartJoinsPoint();
			if (startJoinsPoint != null && startJoinsPoint.isSameLocation(thisLoc)) {
				startJoinsPoint.x = destination.x;
				startJoinsPoint.y = destination.y;
				startJoinsPoint.z = destination.z;
			}
		}
	}

	/**
	 * Gets the first node index associated with the specified image coordinates.
	 * Returns -1 if no such node was found.
	 *
	 * @param pim the image position (calibrated coordinates)
	 * @return the index of the first node occurrence or -1 if there is no such
	 *         occurrence
	 */
	public int getNodeIndex(final PointInImage pim) {
		for (int i = 0; i < points; ++i) {
			if (Math.abs(precise_x_positions[i] - pim.x) < x_spacing && Math.abs(
				precise_y_positions[i] - pim.y) < y_spacing && Math.abs(
					precise_z_positions[i] - pim.z) < z_spacing)
			{
				return i;
			}
		}
		return -1;
	}

	/**
	 * Gets the closest node associated with the specified node.
	 *
	 * @param node   location to be searched for
	 * @param within sets the search sensitivity. E.g., Setting it to
	 *               Double.MAX_VALUE (or the image's largest dimension) will always
	 *               return a valid node.
	 * @return the closest node to the specified one or null if no such node was
	 *         found.
	 */
	public PointInImage nearestNodeTo(final PointInImage node,
		final double within)
	{
		double minimumDistanceSquared = within * within;
		PointInImage closestNode = null;
		for (int i = 0; i < size(); ++i) {
			final PointInImage cNode = getNodeWithoutChecks(i);
			final double thisDistanceSquared = cNode.distanceSquaredTo(node);
			if (thisDistanceSquared < minimumDistanceSquared) {
				closestNode = cNode;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}
		return closestNode;
	}

	/**
	 * Gets the index of the closest node associated with the specified world
	 * coordinates.
	 *
	 * @param x the x-coordinates (spatially calibrated image units)
	 * @param y the y-coordinates (spatially calibrated image units)
	 * @param z the z-coordinates (spatially calibrated image units)
	 * @param within sets the search sensitivity. E.g., Setting it to
	 *          Double.MAX_VALUE (or the image's largest dimension) will always
	 *          return a valid index.
	 * @return the index of the closest node to the specified coordinates. Returns
	 *         -1 if no such node was found.
	 */
	public int indexNearestTo(final double x, final double y, final double z,
		final double within)
	{

		if (size() < 1) throw new IllegalArgumentException(
			"indexNearestTo called on a Path of size() = 0");

		double minimumDistanceSquared = within * within;
		int indexOfMinimum = -1;

		for (int i = 0; i < size(); ++i) {

			final double diff_x = x - precise_x_positions[i];
			final double diff_y = y - precise_y_positions[i];
			final double diff_z = z - precise_z_positions[i];

			final double thisDistanceSquared = diff_x * diff_x + diff_y * diff_y +
				diff_z * diff_z;

			if (thisDistanceSquared < minimumDistanceSquared) {
				indexOfMinimum = i;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}

		return indexOfMinimum;
	}

	protected int indexNearestToCanvasPosition2D(final double xInCanvas,
		final double yInCanvas, final double withinPixels)
	{
		double minimumDistanceSquared = withinPixels * withinPixels;
		int indexOfMinimum = -1;
		for (int i = 0; i < size(); ++i) {
			final double diff_x = xInCanvas - getXUnscaledDouble(i);
			final double diff_y = yInCanvas - getYUnscaledDouble(i);
			final double thisDistanceSquared = diff_x * diff_x + diff_y * diff_y;
			if (thisDistanceSquared < minimumDistanceSquared) {
				indexOfMinimum = i;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}
		return indexOfMinimum;
	}

	protected int indexNearestTo(final double x, final double y, final double z) {
		return indexNearestTo(x, y, z, Double.MAX_VALUE);
	}

	/**
	 * Gets the position of the node tagged as 'editable', if any.
	 *
	 * @return the index of the point currently tagged as editable, or -1 if no
	 *         such point exists
	 */
	public int getEditableNodeIndex() {
		return editableNodeIndex;
	}

	/**
	 * Tags the specified point position as 'editable'.
	 *
	 * @param index the index of the point to be tagged. Set it to -1 to for no
	 *          tagging
	 */
	public void setEditableNode(final int index) {
		this.editableNodeIndex = index;
	}

	protected boolean isBeingEdited() {
		return editableNodeIndex != -1;
	}

	protected void stopBeingEdited() {
		editableNodeIndex = -1;
	}

	protected boolean isEditableNodeLocked() {
		return editableNodeLocked;
	}

	protected void setEditableNodeLocked(final boolean editableNodeLocked) {
		this.editableNodeLocked = editableNodeLocked;
//		System.out.println(getName()+ " is now " + isEditableNodeLocked());
	}

	public int getXUnscaled(final int i) {
		return (int) Math.round(getXUnscaledDouble(i));
	}

	public int getYUnscaled(final int i) {
		return (int) Math.round(getYUnscaledDouble(i));
	}

	public int getZUnscaled(final int i) {
		return (int) Math.round(getZUnscaledDouble(i));
	}

	public double getXUnscaledDouble(final int i) {
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getXUnscaled was asked for an out-of-range point: " + i);
		return precise_x_positions[i] / x_spacing + canvasOffset.x;
	}

	public double getYUnscaledDouble(final int i) {
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getYUnscaled was asked for an out-of-range point: " + i);
		return precise_y_positions[i] / y_spacing + canvasOffset.y;
	}

	public double getZUnscaledDouble(final int i) {
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getZUnscaled was asked for an out-of-range point: " + i);
		return precise_z_positions[i] / z_spacing + canvasOffset.z;
	}

	/**
	 * Gets a section between two nodes of this Path.
	 *
	 * @param startIndex the node index defining the first node of the section
	 * @param endIndex   the node index defining the last node of the section
	 * @return the section. Note that the sectioned Path will share of all of this
	 *         Path's properties but will not contain any information on junction
	 *         points or connectivity to other Paths.
	 */
	public Path getSection(final int startIndex, final int endIndex) {
		if (startIndex < 0 || endIndex > size() || endIndex < startIndex) {
			throw new IllegalArgumentException("Indices out of range!");
		}
		final Calibration cal = getCalibration();
		final Path sub = new Path(cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), size());
		sub.points = endIndex - startIndex + 1;
		sub.precise_x_positions = Arrays.copyOfRange(precise_x_positions, startIndex, endIndex + 1);
		sub.precise_y_positions = Arrays.copyOfRange(precise_y_positions, startIndex, endIndex + 1);
		sub.precise_z_positions = Arrays.copyOfRange(precise_z_positions, startIndex, endIndex + 1);
		if (radii != null)
			sub.radii = Arrays.copyOfRange(radii, startIndex, endIndex + 1);
		if (tangents_x != null)
			sub.tangents_x = Arrays.copyOfRange(tangents_x, startIndex, endIndex + 1);
		if (tangents_y != null)
			sub.tangents_y = Arrays.copyOfRange(tangents_y, startIndex, endIndex + 1);
		if (tangents_z != null)
			sub.tangents_z = Arrays.copyOfRange(tangents_z, startIndex, endIndex + 1);
		if (nodeValues != null)
			sub.nodeValues = Arrays.copyOfRange(nodeValues, startIndex, endIndex + 1);
		if (nodeAnnotations != null)
			sub.nodeAnnotations = Arrays.copyOfRange(nodeAnnotations, startIndex, endIndex + 1);
		if (nodeHemisphereFlags != null)
			sub.nodeHemisphereFlags = Arrays.copyOfRange(nodeHemisphereFlags, startIndex, endIndex + 1);
		if (nodeColors != null)
			sub.nodeColors = Arrays.copyOfRange(nodeColors, startIndex, endIndex + 1);
		if (getFitted() != null)
			sub.setFitted(getFitted().getSection(startIndex, endIndex));
		applyCommonProperties(sub);
		return sub;
	}

	private void applyCommonProperties(final Path other) {
		other.setOrder(getOrder());
		other.setIsPrimary(isPrimary());
		other.setSWCType(getSWCType());
		other.setCTposition(getChannel(), getFrame());
		other.setEditableNode((getEditableNodeIndex() < other.size()) ? getEditableNodeIndex() : -1);
		other.setCanvasOffset(getCanvasOffset());
		other.setColor(getColor());
		other.setSpineOrVaricosityCount(getSpineOrVaricosityCount());
		other.id = id;
		other.editableNodeIndex = editableNodeIndex;
		other.editableNodeLocked = editableNodeLocked;
	}

	/**
	 * Returns a new Path with this Path's attributes (e.g. spatial scale), but no nodes.
	 *
	 * @return the empty path
	 */
	public Path createPath() {
		final Calibration cal = getCalibration();
		final Path dup = new Path(cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), points);
		applyCommonProperties(dup);
		if (hasRadii())
			dup.createCircles();
		return dup;
	}

	protected void setSpacing(final Calibration cal) {
		this.x_spacing = cal.pixelWidth;
		this.y_spacing = cal.pixelHeight;
		this.z_spacing = cal.pixelDepth;
		this.spacing_units = cal.getUnit();
	}

	@SuppressWarnings("unchecked")
	@Override
	public Path clone() {

		final Calibration cal = getCalibration();
		final Path dup = new Path(cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), size());
		dup.points = points;
		dup.precise_x_positions = precise_x_positions.clone();
		dup.precise_y_positions = precise_y_positions.clone();
		dup.precise_z_positions = precise_z_positions.clone();
		if (radii != null) dup.radii = radii.clone();
		if (tangents_x != null) dup.tangents_x = tangents_x.clone();
		if (tangents_y != null) dup.tangents_y = tangents_y.clone();
		if (tangents_z != null) dup.tangents_z = tangents_z.clone();
		if (nodeValues != null) dup.nodeValues = nodeValues.clone();
		if (nodeAnnotations != null) dup.nodeAnnotations = nodeAnnotations.clone();
		if (nodeHemisphereFlags != null) dup.nodeHemisphereFlags = nodeHemisphereFlags.clone();
		dup.somehowJoins = (ArrayList<Path>) somehowJoins.clone();
		dup.children = (ArrayList<Path>) children.clone();
		if (startJoins != null) dup.startJoins = startJoins.clone();
		if (startJoinsPoint != null) dup.startJoinsPoint = startJoinsPoint.clone(); 
		if (getFitted() != null) dup.setFitted(getFitted().clone());
		dup.setNodeColors(getNodeColors());
		applyCommonProperties(dup);
		return dup;
	}

	@Deprecated
	public Path clone(final boolean includeImmediateChildren) {
		final Path dup = clone();
		if (!includeImmediateChildren) return dup;

		dup.children = new ArrayList<>(children.size());
		final Iterator<Path> childrenIt = children.iterator();
		while (childrenIt.hasNext()) {
			final Path child = childrenIt.next();
			final Path dupChild = child.clone();
			if (dupChild.getStartJoinsPoint() != null) {
				final PointInImage dupSPoint = dupChild.getStartJoinsPoint().clone();
				dupChild.unsetStartJoin();
				dupChild.setStartJoin(dup, dupSPoint);
			}
			dup.children.add(dupChild);
		}
		return dup;
	}

	public ArrayList<Path> getChildren() {
		return children;
	}

	/**
	 * Gets the spatial calibration of this Path.
	 *
	 * @return the calibration details associated with this Path
	 */
	public Calibration getCalibration() {
		final Calibration cal = new Calibration();
		cal.setUnit(spacing_units);
		cal.pixelWidth = x_spacing;
		cal.pixelHeight = y_spacing;
		cal.pixelDepth = z_spacing;
		return cal;
	}

	protected PointInImage lastPoint() {
		if (points < 1) return null;
		else return new PointInImage(precise_x_positions[points - 1],
			precise_y_positions[points - 1], precise_z_positions[points - 1]);
	}

	private void expandTo(final int newMaxPoints) {
		precise_x_positions = expandArray(precise_x_positions, newMaxPoints);
		precise_y_positions = expandArray(precise_y_positions, newMaxPoints);
		precise_z_positions = expandArray(precise_z_positions, newMaxPoints);
		if (hasRadii()) {
			tangents_x = expandArray(tangents_x, newMaxPoints);
			tangents_y = expandArray(tangents_y, newMaxPoints);
			tangents_z = expandArray(tangents_z, newMaxPoints);
			radii = expandArray(radii, newMaxPoints);
		}
		if (nodeValues != null) {
			nodeValues = expandArray(nodeValues, newMaxPoints);
		}
		if (nodeAnnotations != null) {
			final BrainAnnotation[] newNodeAnnotations = new BrainAnnotation[newMaxPoints];
			System.arraycopy(nodeAnnotations, 0, newNodeAnnotations, 0, points);
			nodeAnnotations = newNodeAnnotations;
		}
		if (nodeHemisphereFlags != null) {
			final char[] newNodeHemisphereFlags = new char[newMaxPoints];
			System.arraycopy(nodeHemisphereFlags, 0, newNodeHemisphereFlags, 0, points);
			nodeHemisphereFlags = newNodeHemisphereFlags;
		}
		maxPoints = newMaxPoints;
	}

	private static double[] expandArray(final double[] array, final int newCapacity) {
		final double[] expanded = new double[newCapacity];
		System.arraycopy(array, 0, expanded, 0, array.length);
		return expanded;
	}

	public void add(final Path other) {

		if (other == null) {
			SNTUtils.warn("BUG: Trying to add null Path");
			return;
		}

		// If we're trying to add a path with circles to one
		// that previously had none, add circles to the
		// previous one, and carry on:

		if (other.hasRadii() && !hasRadii()) {
			createCircles();
			final double defaultRadius = getMinimumSeparation() * 2;
			for (int i = 0; i < points; ++i)
				radii[i] = defaultRadius;
		}

		if (maxPoints < (points + other.points)) {
			expandTo(points + other.points);
		}

		int toSkip = 0;

		/*
		 * We may want to skip some points at the beginning of the next path if they're
		 * the same as the last point on this path:
		 */
		if (points > 0) {
			final double last_x = precise_x_positions[points - 1];
			final double last_y = precise_y_positions[points - 1];
			final double last_z = precise_z_positions[points - 1];
			while ((other.precise_x_positions[toSkip] == last_x) &&
				(other.precise_y_positions[toSkip] == last_y) &&
				(other.precise_z_positions[toSkip] == last_z))
			{
				++toSkip;
			}
		}

		System.arraycopy(other.precise_x_positions, toSkip, precise_x_positions,
			points, other.points - toSkip);
		System.arraycopy(other.precise_y_positions, toSkip, precise_y_positions,
			points, other.points - toSkip);
		System.arraycopy(other.precise_z_positions, toSkip, precise_z_positions,
			points, other.points - toSkip);

		if (hasRadii() && other.hasRadii()) {
			System.arraycopy(other.radii, toSkip, radii, points, other.points -
				toSkip);
		}

		points = points + (other.points - toSkip);

		if (hasRadii()) {
			setGuessedTangents(2);
		}
	}

	/**
	 * Reverses this path so that its starting node becomes the last and vice versa.
	 */
	public void reverse() {
		reverseInSitu(this);
	}

	/**
	 * 
	 * @return a reversed version of this path in which node coordinates are
	 *         reversed. Note that for legacy reasons only the node coordinates are
	 *         reversed. Other properties (node colors, etc.) are not included in
	 *         the returned path
	 */
	public Path reversed() {
		final Path c = createPath();
		c.points = points;
		for (int i = 0; i < points; ++i) {
			c.precise_x_positions[i] = precise_x_positions[(points - 1) - i];
			c.precise_y_positions[i] = precise_y_positions[(points - 1) - i];
			c.precise_z_positions[i] = precise_z_positions[(points - 1) - i];
		}
		if (c.fitted != null)
			c.fitted = c.fitted.reversed();
		return c;
	}

	private static void reverseInSitu(final Path c) {
		ArrayUtils.reverse(c.precise_x_positions, 0, c.points);
		ArrayUtils.reverse(c.precise_y_positions, 0, c.points);
		ArrayUtils.reverse(c.precise_z_positions, 0, c.points);
		ArrayUtils.reverse(c.radii, 0, c.points);
		ArrayUtils.reverse(c.tangents_x, 0, c.points);
		ArrayUtils.reverse(c.tangents_y, 0, c.points);
		ArrayUtils.reverse(c.nodeValues, 0, c.points);
		ArrayUtils.reverse(c.nodeAnnotations, 0, c.points);
		ArrayUtils.reverse(c.nodeHemisphereFlags, 0, c.points);
		ArrayUtils.reverse(c.nodeColors, 0, c.points);
		if (c.editableNodeIndex > -1)
			c.editableNodeIndex = c.points - 1 - c.editableNodeIndex;
		if (c.fitted != null)
			reverseInSitu(c.fitted);
	}

	/**
	 * Appends a node to this Path.
	 *
	 * @param point the node to be inserted
	 */
	public void addNode(final PointInImage point) {
		addCommonPropertiesNode(point);
		if (!Double.isNaN(point.v)) setNodeValue(point.v, size() - 1);
		if (point instanceof SWCPoint) {
			final double radius = ((SWCPoint)point).radius;
			if (radius > 0) {
				if (!hasRadii()) createCircles();
				radii[size() - 1] = ((SWCPoint)point).radius;
			}
		}
	}

	private void addCommonPropertiesNode(final SNTPoint point) {
		addPointDouble(point.getX(), point.getY(), point.getZ());
		if (point.getAnnotation() != null) setNodeAnnotation(point.getAnnotation(), size() - 1);
		if (point.getHemisphere() != BrainAnnotation.ANY_HEMISPHERE) setNodeHemisphere(point.getHemisphere(), size() - 1);
	}

	public void addPointDouble(final double x, final double y, final double z) {
		if (points >= maxPoints) {
			final int newReserved = (int) (maxPoints * 1.2 + 1);
			expandTo(newReserved);
		}
		precise_x_positions[points] = x;
		precise_y_positions[points] = y;
		precise_z_positions[points++] = z;
	}

	public void drawPathAsPoints(final TracerCanvas canvas, final Graphics2D g,
		final java.awt.Color c, final int plane, final boolean highContrast,
		final boolean drawDiameter)
	{
		drawPathAsPoints(canvas, g, c, highContrast, drawDiameter, 0, -1);
	}

	protected void drawPathAsPoints(final TracerCanvas canvas, final Graphics2D g,
		final java.awt.Color c, final int plane, final boolean drawDiameter,
		final int slice, final int either_side)
	{
		drawPathAsPoints(canvas, g, c, false, drawDiameter, slice,
			either_side);
	}

	protected void drawPathAsPoints(final Graphics2D g2,
		final TracerCanvas canvas, final SNT snt)
	{
		final boolean customColor = (hasCustomColor && snt.displayCustomPathColors);
		Color color = snt.deselectedColor;
		if (isSelected() && !customColor)
			color = snt.selectedColor;
		else if (customColor)
			color = getColor();
		final int sliceZeroIndexed = canvas.getImage().getZ() - 1;
		int eitherSideParameter = canvas.eitherSide;
		if (!canvas.just_near_slices)
			eitherSideParameter = -1;
		drawPathAsPoints(canvas, g2, color, customColor,
			snt.getDrawDiameters(), sliceZeroIndexed, eitherSideParameter);
	}

	public void drawPathAsPoints(final TracerCanvas canvas, final Graphics2D g2,
		final java.awt.Color c, final boolean highContrast,
		boolean drawDiameter, final int slice, final int either_side)
	{

		if (points == 0) {
			new PathNode(this, 0, PathNode.HERMIT, canvas).draw(g2, c);
			return;
		}
		int startIndexOfLastDrawnLine = -1;

		for (int i = 0; i < points; ++i) {

			final PathNode currentNode = new PathNode(this, i, canvas);
			PathNode previousNode = null;
			PathNode nextNode = null;
			if (i > 0) {
				previousNode = new PathNode(this, i-1, canvas);
			} else if (startJoinsPoint != null) {
				previousNode = new PathNode(startJoinsPoint, i, canvas);
			}
			if (i < points - 1) {
				nextNode = new PathNode(this, i+1, canvas);
			}

			final boolean outOfDepthBounds = (either_side >= 0) && (Math.abs(
					currentNode.getSlice() - slice) > either_side);

			// Draw node
			if (!outOfDepthBounds) {
				//System.out.println("Drawing node: " + g2.getColor());
				currentNode.setEditable(getEditableNodeIndex() == i);
				currentNode.draw(g2, c);
			}

			// Options for drawing inter-node segments and node diameter. Color
			// will be whatever has been set by PathNode#Draw(). If 2D canvas,
			// out-of-bounds transparency is ignored
			g2.setStroke(new BasicStroke((float) (canvas.nodeDiameter() / 3), BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
			g2.setColor(SNTColor.alphaColor(g2.getColor(),
					(outOfDepthBounds && either_side > -1) ? canvas.getOutOfBoundsTransparency()
							: canvas.getDefaultTransparency()));

			// We are within Z-bounds and have been asked to draw the diameters, just do it in XY
			if (drawDiameter && !outOfDepthBounds) {
				currentNode.drawDiameter(g2, slice, either_side);
			}

			// If there was a previous point in this path, draw a line from there to here:
			if (i > 0) {
				// Don't redraw the line if we drew it the previous time, though:
				if (startIndexOfLastDrawnLine != i - 1) {
					currentNode.drawConnection(g2, previousNode);
					startIndexOfLastDrawnLine = i - 1;
				}
			} 
			else if (getStartJoinsPoint() != null) {
				final PathNode jointNode = new PathNode(getStartJoinsPoint(), i, canvas);
				jointNode.setType(PathNode.JOINT);
				jointNode.draw(g2, c);
				currentNode.setType(PathNode.SLAB);
				currentNode.drawConnection(g2, previousNode);
			}
			// If there's a next point in this path, draw a line from here to there:
			if (nextNode != null) {
				currentNode.drawConnection(g2, nextNode);
				startIndexOfLastDrawnLine = i;
			}

		}

	}

	/**
	 * Sets the node colors.
	 *
	 * @param colors the colors used to render the nodes of this. If null (the
	 *          default) all nodes are rendered using the Path color.
	 */
	public void setNodeColors(final Color[] colors) {
		if (colors != null && colors.length != size()) {
			throw new IllegalArgumentException(
				"colors array must have as many elements as nodes");
		}
		nodeColors = colors;
	}

	/**
	 * Gets the node colors.
	 *
	 * @return the colors used to render the nodes of this path, or null if nodes
	 *         are rendered using the Path color
	 */
	public Color[] getNodeColors() {
		return nodeColors;
	}

	/**
	 * Gets the node color.
	 *
	 * @param pos the node position
	 * @return the node color, or null if no color nodes have been assigned to
	 *         this path
	 */
	public Color getNodeColor(final int pos) {
		return (nodeColors == null) ? null : nodeColors[pos];
	}

	/**
	 * Sets the node color.
	 *
	 * @param color the node color
	 * @param pos the node position
	 */
	public void setNodeColor(final Color color, final int pos) {
		if (nodeColors == null) nodeColors = new Color[size()];
		nodeColors[pos] = color;
	}

	/**
	 * Sets the node color.
	 *
	 * @param color the node color
	 * @param pos the node position
	 */
	public void setNodeColor(final ColorRGB color, final int pos) {
		setNodeColor((color == null) ? null : new Color(color.getARGB()), pos);
	}

	/**
	 * Assigns the "value" property to this node.
	 *
	 * @param value the node value
	 * @param pos the node position
	 * @see PathProfiler#assignValues()
	 */
	public void setNodeValue(final double value, final int pos) {
		if (nodeValues == null) {
			nodeValues = new double[maxPoints];
		}
		nodeValues[pos] = value;
	}

	/**
	 * Assigns an annotation to an existing node.
	 *
	 * @param annotation the node annotation
	 * @param pos the node position
	 */
	public void setNodeAnnotation(final BrainAnnotation annotation, final int pos) {
		if (nodeAnnotations == null) {
			nodeAnnotations = new BrainAnnotation[maxPoints];
		}
		nodeAnnotations[pos] = annotation;
	}

	/**
	 * Assigns a hemisphere to an existing node.
	 *
	 * @param hemisphereFlag the node hemisphere flag.
	 * @param pos the node position
	 */
	public void setNodeHemisphere(final char hemisphereFlag, final int pos) {
		if (nodeHemisphereFlags == null) {
			nodeHemisphereFlags = new char[maxPoints];
		}
		nodeHemisphereFlags[pos] = hemisphereFlag;
	}

	/**
	 * Returns the "value" property of this node.
	 *
	 * @param pos the node position
	 * @return the value property of this node
	 * @see PathProfiler#assignValues()
	 * @see PointInImage#v
	 */
	public double getNodeValue(final int pos) {
		return (nodeValues == null) ? null : nodeValues[pos];
	}

	/**
	 * Returns the neuropil annotation associated with this node.
	 *
	 * @param pos the node position
	 * @return the annotation of this node,
	 * @see SNTPoint#getAnnotation()
	 */
	public BrainAnnotation getNodeAnnotation(final int pos) {
		return (nodeAnnotations == null) ? null : nodeAnnotations[pos];
	}

	/**
	 * Returns the hemisphere flag associated with this node.
	 *
	 * @param pos the node position
	 * @return the flag associated with this node, either
	 *         {@link BrainAnnotation#LEFT_HEMISPHERE},
	 *         {@link BrainAnnotation#RIGHT_HEMISPHERE}, or
	 *         {@link BrainAnnotation#ANY_HEMISPHERE}
	 * @see SNTPoint#getAnnotation()
	 */
	public char getNodeHemisphereFlag(final int pos) {
		return (nodeHemisphereFlags == null) ? BrainAnnotation.ANY_HEMISPHERE : nodeHemisphereFlags[pos];
	}

	/**
	 * Sets the path "values", the array containing the numeric property assigned
	 * to path nodes, typically voxel intensities.
	 *
	 * @param values the new node values
	 * @see PointInImage#v
	 * @see PathProfiler#assignValues()
	 */
	public void setNodeValues(final double[] values) {
		if (values != null && values.length != size()) {
			throw new IllegalArgumentException(
				"values array must have as many elements as nodes");
		}
		this.nodeValues = (values == null) ? null : values.clone();
	}

	/**
	 * Assesses whether the nodes of this path have been assigned an array of
	 * values
	 *
	 * @return true, if successful
	 * @see PointInImage#v
	 * @see PathProfiler#assignValues()
	 */
	public boolean hasNodeValues() {
		return nodeValues != null;
	}

	/**
	 * Assesses whether the nodes of this path have been assigned
	 * {@link BrainAnnotation}s.
	 *
	 * @return true, if successful
	 * @see SNTPoint#getAnnotation()
	 */
	public boolean hasNodeAnnotations() {
		return nodeAnnotations != null;
	}

	/**
	 * Assesses whether the nodes of this path have been assigned hemisphere flags.
	 *
	 * @return true, if successful
	 * @see SNTPoint#getHemisphere()
	 */
	public boolean hasNodeHemisphereFlags() {
		return nodeHemisphereFlags != null;
	}

	/**
	 * Gets the color of this Path
	 *
	 * @return the color, or null if no color has been assigned to this Path
	 * @see #hasCustomColor
	 * @see #hasNodeColors()
	 */
	public Color getColor() {
		return color;
	}

	/**
	 * Gets the color of this Path
	 *
	 * @return the color, or null if no color has been assigned to this Path
	 * @see #hasCustomColor
	 * @see #hasNodeColors()
	 */
	public ColorRGB getColorRGB() {
			return (color == null) ? null : new ColorRGB(color.getRed(), color
				.getGreen(), color.getBlue());
	}

	/**
	 * Sets this path color.
	 *
	 * @param color the path color. Set it to null, to have SNT render this Path
	 *              using default settings. You may need to cast the null reference
	 *              to {@code Color} to avoid ambiguous method overload
	 */
	public void setColor(final Color color) {
		this.color = color;
		hasCustomColor = color != null;
		if (getFitted() != null) getFitted().setColor(color);
		if (hasNodeColors() && size() == 1) nodeColors[0] = color;
	}

	/**
	 * Sets this path color.
	 *
	 * @param color the path color. Set it to null, to have SNT render this Path
	 *              using default settings. You may need to cast the null reference
	 *              to {@code ColorRGB} to avoid ambiguous method overload
	 */
	public void setColor(final ColorRGB color) {
		if (color == null)
			setColor((Color)null);
		else if (color instanceof ColorRGBA)
			setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha()));
		else
			setColor(new Color(color.getARGB()));
	}

	/**
	 * Resets this path color, forcing SNT to render it under default settings.
	 */
	public void resetColor() {
		setColor((Color)null);
	}

	/**
	 * Assesses whether a custom color has been assigned to this Path.
	 *
	 * @return true, if successful
	 * @see #hasNodeColors()
	 */
	public boolean hasCustomColor() {
		return (hasCustomColor && color != null); // backwards compatibility: we cannot include hasNodeColors()
	}

	/**
	 * Assesses whether the nodes of this path have been assigned an array of
	 * colors
	 *
	 * @return true, if successful
	 * @see #getNodeColors()
	 */
	public boolean hasNodeColors() {
		return nodeColors != null;
	}

	/**
	 * Gets the default SWC colors used by SNT.
	 *
	 * @param swcType the SEC type (e.g., {@link Path#SWC_AXON},
	 *          {@link Path#SWC_DENDRITE}, etc.)
	 * @return the SWC color
	 */
	public static Color getSWCcolor(final int swcType) {
		switch (swcType) {
			case Path.SWC_SOMA:
				return Color.BLUE;
			case Path.SWC_AXON:
				return Color.RED;
			case Path.SWC_DENDRITE:
				return Color.GREEN;
			case Path.SWC_APICAL_DENDRITE:
				return Color.CYAN;
			case Path.SWC_CUSTOM:
				return Color.YELLOW;
			case Path.SWC_UNSPECIFIED:
				return Color.ORANGE;
			case Path.SWC_GLIA_PROCESS:
				return Color.PINK;
			case Path.SWC_CUSTOM2:
				return Color.YELLOW.darker();
			case Path.SWC_UNDEFINED:
			default:
				return SNT.DEFAULT_DESELECTED_COLOR;
		}
	}

	/**
	 * Checks if this Path is a fitted version of another path.
	 *
	 * @return true, if it is a fitted version of another path
	 */
	public boolean isFittedVersionOfAnotherPath() {
		return fittedVersionOf != null;
	}

	protected void setFitted(final Path p) {
		if (getFitted() != null && p != null) {
			throw new IllegalArgumentException(
				"BUG: Trying to set a fitted path when there already is one...");
		}
		fitted = p;
		if (p == null) {
			setUseFitted(false);
		} else {
			p.fittedVersionOf = this;
			p.setIDs(-getID(), getTreeID());
//			System.out.println("Just set " + p.getName() + " is a fitted version of " + getName() );
		}
	}

	/**
	 * Sets whether the fitted flavor of this Path should be used.
	 *
	 * @param useFitted the new use fitted
	 * @throws IllegalArgumentException if this Path has not been fitted
	 */
	public void setUseFitted(final boolean useFitted)
		throws IllegalArgumentException
	{
		if (useFitted && getFitted() == null) throw new IllegalArgumentException(
			"setUseFitted(true) called, but 'fitted' member was null");
		this.useFitted = useFitted;
	}

	protected void discardFit() {
		fitted = null;
		useFitted = false;
	}

	/**
	 * Gets whether the fitted 'flavor' of this Path is in use.
	 *
	 * @return true, if the fitted version of this Path is in use, otherwise false
	 */
	public boolean getUseFitted() {
		return useFitted && fitted != null;
	}

	public int getSpineOrVaricosityCount() {
		return spinesOrVaricosities;
	}

	public void setSpineOrVaricosityCount(final int newCount) {
		this.spinesOrVaricosities = newCount;
		if (fitted != null) fitted.setSpineOrVaricosityCount(newCount);
	}

	/**
	 * Gets the hyperstack channel associated with this Path.
	 *
	 * @return the channel position of this path (1-based index). Note that if the
	 *         channel associated with a path is not known, it is assumed to be 1;
	 */
	public int getChannel() {
		return ctPosition[0];
	}

	/**
	 * Gets the hyperstack frame position associated with this Path.
	 *
	 * @return the frame position of this path (1-based index). Note that if the
	 *         frame associated with a path is not known, it is assumed to be 1;
	 */
	public int getFrame() {
		return ctPosition[1];
	}

	/**
	 * Sets the hyperstack position of this Path
	 *
	 * @param channel the channel (one-based index)
	 * @param frame the frame (one-based index)
	 */
	public void setCTposition(final int channel, final int frame) {
		ctPosition[0] = channel;
		ctPosition[1] = frame;
	}

	/**
	 * Gets the fitted version ('flavor') of this Path.
	 *
	 * @return the fitted version, or null if this Path has not been fitted
	 */
	public Path getFitted() {
		return fitted;
	}

	public void setGuessedTangents(final int pointsEitherSide) {
		if (tangents_x == null || tangents_y == null || tangents_z == null) {
//			throw new IllegalArgumentException(
//			"BUG: setGuessedTangents called with one of the tangent arrays null");
			createCircles();
		}
		final double[] tangent = new double[3];
		for (int i = 0; i < points; ++i) {
			getTangent(i, pointsEitherSide, tangent);
			tangents_x[i] = tangent[0];
			tangents_y[i] = tangent[1];
			tangents_z[i] = tangent[2];
		}
	}

	public void getTangent(final int i, final int pointsEitherSide,
		final double[] result)
	{
		int min_index = i - pointsEitherSide;
		if (min_index < 0) min_index = 0;

		int max_index = i + pointsEitherSide;
		if (max_index >= points) max_index = points - 1;

		result[0] = precise_x_positions[max_index] - precise_x_positions[min_index];
		result[1] = precise_y_positions[max_index] - precise_y_positions[min_index];
		result[2] = precise_z_positions[max_index] - precise_z_positions[min_index];
	}

	/**
	 * Gets the list of string representations of non-redundant SWC types (i.e.,
	 * excluding {@link Path#SWC_FORK_POINT_LABEL}, and
	 * {@link Path#SWC_FORK_POINT_LABEL}
	 *
	 * @return the list of SWC type names
	 */
	public static ArrayList<String> getSWCtypeNames() {
		final ArrayList<String> swcTypes = new ArrayList<>();
		swcTypes.add(SWC_UNDEFINED_LABEL);
		swcTypes.add(SWC_SOMA_LABEL);
		swcTypes.add(SWC_AXON_LABEL);
		swcTypes.add(SWC_DENDRITE_LABEL);
		swcTypes.add(SWC_APICAL_DENDRITE_LABEL);
		// swcTypes.add(SWC_FORK_POINT_LABEL);
		// swcTypes.add(SWC_END_POINT_LABEL);
		swcTypes.add(SWC_CUSTOM_LABEL);
		return swcTypes;
	}

	/**
	 * Gets the list of non-redundant SWC types (i.e., excluding the redundant
	 * types {@link Path#SWC_FORK_POINT_LABEL}, and
	 * {@link Path#SWC_FORK_POINT_LABEL}
	 *
	 * @return the list of SWC type flags
	 */
	public static ArrayList<Integer> getSWCtypes() {
		final ArrayList<Integer> swcTypes = new ArrayList<>();
		swcTypes.add(SWC_UNDEFINED);
		swcTypes.add(SWC_SOMA);
		swcTypes.add(SWC_AXON);
		swcTypes.add(SWC_DENDRITE);
		swcTypes.add(SWC_APICAL_DENDRITE);
		// swcTypes.add(SWC_FORK_POINT);
		// swcTypes.add(SWC_END_POINT);
		swcTypes.add(SWC_CUSTOM);
		return swcTypes;
	}

	/**
	 * Gets the SWC type label associated with the specified type flag. SNT
	 * follows the specification detailed at <a href=
	 * "http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html">neuronland</a>
	 *
	 * @param type the SWC type flag
	 * @param capitalized whether output String should be capitalized
	 * @return the respective label, or {@link Path#SWC_UNDEFINED_LABEL} if flag
	 *         was not recognized
	 */
	public static String getSWCtypeName(final int type,
		final boolean capitalized)
	{
		String typeName;
		switch (type) {
			case SWC_SOMA:
				typeName = SWC_SOMA_LABEL;
				break;
			case SWC_AXON:
				typeName = SWC_AXON_LABEL;
				break;
			case SWC_DENDRITE:
				typeName = SWC_DENDRITE_LABEL;
				break;
			case SWC_APICAL_DENDRITE:
				typeName = SWC_APICAL_DENDRITE_LABEL;
				break;
			case SWC_CUSTOM:
				typeName = SWC_CUSTOM_LABEL;
				break;
			case SWC_UNSPECIFIED:
				typeName = SWC_UNSPECIFIED_LABEL;
				break;
			case SWC_GLIA_PROCESS:
				typeName = SWC_GLIA_PROCESS_LABEL;
				break;
			case SWC_CUSTOM2:
				typeName = SWC_CUSTOM2_LABEL;
				break;
			case SWC_UNDEFINED:
			default:
				typeName = SWC_UNDEFINED_LABEL;
				break;
		}
		if (!capitalized) return typeName;

		final char[] buffer = typeName.toCharArray();
		boolean capitalizeNext = true;
		for (int i = 0; i < buffer.length; i++) {
			final char ch = buffer[i];
			if (Character.isWhitespace(ch) || !Character.isLetter(ch)) {
				capitalizeNext = true;
			}
			else if (capitalizeNext) {
				buffer[i] = Character.toTitleCase(ch);
				capitalizeNext = false;
			}
		}
		return new String(buffer);
	}

	/**
	 * Gets the path mean radius.
	 *
	 * @return the average radius of the path, or zero if path has no defined
	 *         thickness
	 * @see #hasRadii()
	 */
	public double getMeanRadius() {
		return (hasRadii()) ? StatUtils.mean(radii) : 0;
	}

	/**
	 * Gets the radius of the specified node.
	 *
	 * @param pos the node position
	 * @return the radius at the specified position, or zero if path has no
	 *         defined thickness
	 */
	public double getNodeRadius(final int pos) {
		if (radii == null) return 0;
		if ((pos < 0) || pos >= size()) {
			throw new IllegalArgumentException(
				"getNodeRadius() was asked for an out-of-range point: " + pos);
		}
		return radii[pos];
	}

	/**
	 * Checks whether the nodes of this path have been assigned defined thickness.
	 *
	 * @return true, if the points defining with this path are associated with a
	 *         list of radii
	 */
	public boolean hasRadii() {
		return radii != null;
	}

	/**
	 * Uses linear interpolation to correct nodes with invalid radius.
	 * 
	 * Collects nodes with invalid radii (zero, NaN, or negative values) and assigns
	 * them new values using linear interpolation based on remaining nodes with
	 * valid radii.
	 * 
	 * @param apply If {@code true} interpolated values are immediately to this
	 *              path. If false, nodes remain unchanged.
	 * @return the map containing the (node index, interpolated radius) pairs or
	 *         null if current path has not been assigned radii or has less than 2
	 *         nodes. Note that the map keys hold only the indices for which
	 *         interpolation succeed, which may be a subset of all the nodes with
	 *         invalid radii.
	 */
	public Map<Integer, Double> interpolateMissingRadii(final boolean apply) {
		return interpolateMissingRadii((x) -> {
			return x <= 0 || Double.isNaN(x);
		}, apply);
	}

	/**
	 * Uses linear interpolation to correct nodes with invalid radius.
	 * 
	 * Collects nodes with invalid radii (zero, NaN, or negative values) and assigns
	 * them new values using linear interpolation based on remaining nodes with
	 * valid radii.
	 * 
	 * @param predicate the function defining invalid radiii, e.g. {@code (x) -> {
	 *                  return x <= 0 || Double.isNaN(x);} }
	 * @param apply     If {@code true} interpolated values are immediately to this
	 *                  path. If false, nodes remain unchanged.
	 * @return the map containing the (node index, interpolated radius) pairs or
	 *         null if current path has not been assigned radii or has less than 2
	 *         nodes. Note that the map keys hold only the indices for which
	 *         interpolation succeed, which may be a subset of all the nodes with
	 *         invalid radii.
	 */
	public Map<Integer, Double> interpolateMissingRadii(final DoublePredicate predicate, final boolean apply) {
		if (!hasRadii() || size() < 2)
			return null;
		final List<Integer> validIndices = new ArrayList<>();
		final List<Double> validRadii = new ArrayList<>();
		final List<Integer> replacementIndices = new ArrayList<>();
		for (int nodeIdx = 0; nodeIdx < size(); nodeIdx++) {
			if (predicate.test(radii[nodeIdx])) {
				replacementIndices.add(nodeIdx);
			} else {
				validIndices.add(nodeIdx);
				validRadii.add(radii[nodeIdx]);
			}
		}
		final double[] knownIndices = validIndices.stream().mapToDouble(d -> d).toArray();
		final double[] knownRadii = validRadii.stream().mapToDouble(d -> d).toArray();
		final double[] unknownIndices = replacementIndices.stream().mapToDouble(d -> d).toArray();
		final double[] guessedRadii = interpolate(knownIndices, knownRadii, unknownIndices);
		final Map<Integer, Double> result = new TreeMap<>();
		for (int idx = 0; idx < unknownIndices.length; idx++) {
			final double r = guessedRadii[idx];
			if (r < 0)
				continue;
			result.put((int) unknownIndices[idx], r);
			if (apply)
				setRadius(r, (int) unknownIndices[idx]);
		}
		return result;
	}

	private double[] interpolate(final double[] x1, final double[] y1, final double[] x2) {
		// see https://stackoverflow.com/a/73716167
		final PolynomialSplineFunction function = new LinearInterpolator().interpolate(x1, y1);
		final PolynomialFunction[] splines = function.getPolynomials();
		final PolynomialFunction firstFunction = splines[0];
		final PolynomialFunction lastFunction = splines[splines.length - 1];
		final double[] knots = function.getKnots();
		final double firstKnot = knots[0];
		final double lastKnot = knots[knots.length - 1];
		final double[] resultList = Arrays.stream(x2).map(d -> {
			if (d > lastKnot) {
				return lastFunction.value(d - knots[knots.length - 2]);
			} else if (d < firstKnot)
				return firstFunction.value(d - knots[0]);
			return function.value(d);
		}).toArray();
		return resultList;
	}

	protected void setFittedCircles(final int nPoints, final double[] tangents_x,
		final double[] tangents_y, final double[] tangents_z,
		final double[] radii, final double[] optimized_x,
		final double[] optimized_y, final double[] optimized_z)
	{
		this.points = nPoints;
		if (tangents_x != null) this.tangents_x = tangents_x.clone();
		if (tangents_y != null) this.tangents_y = tangents_y.clone();
		if (tangents_z != null) this.tangents_z = tangents_z.clone();
		if (radii != null) this.radii = radii.clone();

		this.precise_x_positions = optimized_x.clone();
		this.precise_y_positions = optimized_y.clone();
		this.precise_z_positions = optimized_z.clone();
	}

	/**
	 * This toString() method shows details of the path which is actually being
	 * displayed, not necessarily this path object.
	 *
	 * @return the string
	 */
	@Override
	public String toString() {
		final StringBuilder sb = new StringBuilder(getName());
		if (getUseFitted() && sb.lastIndexOf("(Fitted)") < 0)
			sb.append(" (Fitted)");
		if (size() == 1)
			sb.append(" [Single Point]");
		if (swcType != SWC_UNDEFINED)
			sb.append(" [").append(getSWCtypeName(swcType, false)).append("]");
		return sb.toString();
	}

	/**
	 * Sets the SWC type.
	 *
	 * @param newSWCType the new SWC type
	 */
	public void setSWCType(final int newSWCType) {
		setSWCType(newSWCType, true);
	}

	protected void setSWCType(final int newSWCType,
		final boolean alsoSetInFittedVersion)
	{
		swcType = (newSWCType < 0 ) ? SWC_UNDEFINED : newSWCType;
		if (alsoSetInFittedVersion) {
			/*
			 * If we've been asked to also set the fitted version, this should only be
			 * called on the non-fitted version of the path, so raise an error if it's been
			 * called on the fitted version by mistake instead:
			 */
			if (isFittedVersionOfAnotherPath() && fittedVersionOf
				.getSWCType() != newSWCType) throw new IllegalArgumentException(
					"BUG: only call setSWCType on the unfitted path");
			if (getFitted() != null) getFitted().setSWCType(newSWCType);
		}
	}

	/**
	 * Gets the SWC type.
	 *
	 * @return the SWC type
	 */
	public int getSWCType() {
		return swcType;
	}

	/*
	 * @Override public String toString() { int n = size(); String result = ""; if(
	 * name != null ) result += "\"" + name + "\" "; result += n + " points"; if( n
	 * > 0 ) { result += " from " + x_positions[0] + ", " + y_positions[0] + ", " +
	 * z_positions[0]; result += " to " + x_positions[n-1] + ", " + y_positions[n-1]
	 * + ", " + z_positions[n-1]; } return result; }
	 */

	/**
	 * Gets the "bifurcation" (branching) order of this Path. If registered in the
	 * GUI, this would correspond to the level of this Path in
	 * {@link PathManagerUI}'s JTree: E.g., a Path connected to a primary Path
	 * (order 1) will be assigned order 2, etc. N.B.: Albeit related to reverse
	 * Horton-Strahler classification, Path ordering is formally distinct, as it
	 * classifies <i>Paths</i> instead of <i>branches</i>.
	 *
	 * @return the order of this path. A primary path is always of order 1.
	 * @see sc.fiji.snt.analysis.StrahlerAnalyzer
	 */
	public int getOrder() {
		return order;
	}

	public void setOrder(final int order) {
		this.order = order;
		if (getFitted() != null) getFitted().order = order;
		else if (fittedVersionOf != null) fittedVersionOf.order = order;
	}

	/*
	 * These are various fields that have the current 3D representations of this
	 * path. They should only be updated by synchronized methods, currently:
	 *
	 * updateContent3D addTo3DViewer removeFrom3DViewer
	 */
	int paths3DDisplay = 1;
	Content content3D;
	Content content3DExtra;
	ImagePlus content3DMultiColored;
	ImagePlus content3DExtraMultiColored;
	String nameWhenAddedToViewer;
	String nameWhenAddedToViewerExtra;

	synchronized void removeIncludingFittedFrom3DViewer(
		final Image3DUniverse univ)
	{
		removeFrom3DViewer(univ);
		if (useFitted) getFitted().removeFrom3DViewer(univ);
	}

	synchronized void updateContent3D(final Image3DUniverse univ,
		final boolean visible, final int paths3DDisplay, final Color3f color,
		final ImagePlus colorImage)
	{

//		SNT.log("In updateContent3D, colorImage is: " + colorImage);
//		SNT.log("In updateContent3D, color is: " + color);

		// So, go through each of the reasons why we might
		// have to remove (and possibly add back) the path:

		if (!visible) {
			/*
			 * It shouldn't be visible - if any of the contents are non-null, remove them:
			 */
			removeIncludingFittedFrom3DViewer(univ);
			return;
		}

		// Now we know it should be visible.

		Path pathToUse = null;

		if (useFitted) {
			/*
			 * If the non-fitted versions are currently being displayed, remove them:
			 */
			removeFrom3DViewer(univ);
			pathToUse = getFitted();
		}
		else {
			/*
			 * If the fitted version is currently being displayed, remove it:
			 */
			if (getFitted() != null) {
				getFitted().removeFrom3DViewer(univ);
			}
			pathToUse = this;
		}

//		if (SNT.isDebugMode()) {
//			SNT.log("pathToUse is: " + pathToUse);
//			SNT.log("  pathToUse.content3D is: " + pathToUse.content3D);
//			SNT.log("  pathToUse.content3DExtra is: " + pathToUse.content3DExtra);
//			SNT.log("  pathToUse.content3DMultiColored: " + pathToUse.content3DMultiColored);
//		}

		// Is the display (lines-and-discs or surfaces) right?
		if (pathToUse.paths3DDisplay != paths3DDisplay) {
			pathToUse.removeFrom3DViewer(univ);
			pathToUse.paths3DDisplay = paths3DDisplay;
			pathToUse.addTo3DViewer(univ, color, colorImage);
			return;
		}

		/* Were we previously using a colour image, but now not? */

		if (colorImage == null) {
			if ((paths3DDisplay == SNT.DISPLAY_PATHS_LINES_AND_DISCS &&
				pathToUse.content3DExtraMultiColored != null) ||
				(paths3DDisplay == SNT.DISPLAY_PATHS_SURFACE &&
					pathToUse.content3DMultiColored != null))
			{
				pathToUse.removeFrom3DViewer(univ);
				pathToUse.addTo3DViewer(univ, color, colorImage);
				return;
			}

			/*
			 * ... or, should we now use a colour image, where previously we were using a
			 * different colour image or no colour image?
			 */

		}
		else {
			if ((paths3DDisplay == SNT.DISPLAY_PATHS_LINES_AND_DISCS &&
				pathToUse.content3DExtraMultiColored != colorImage) ||
				(paths3DDisplay == SNT.DISPLAY_PATHS_SURFACE &&
					pathToUse.content3DMultiColored != colorImage))
			{
				pathToUse.removeFrom3DViewer(univ);
				pathToUse.addTo3DViewer(univ, color, colorImage);
				return;
			}
		}

		// Has the path's representation in the 3D viewer been marked as
		// invalid?

		if (pathToUse.is3DViewInvalid()) {
			pathToUse.removeFrom3DViewer(univ);
			pathToUse.addTo3DViewer(univ, color, colorImage);
			invalid3DMesh = false;
			return;
		}

		// Is the (flat) color wrong?

		if (pathToUse.realColor == null || !pathToUse.realColor.equals(color)) {

			/*
			 * If there's a representation of the path in the 3D viewer anyway, just set the
			 * color, don't recreate it, since the latter takes a long time:
			 */

			if (pathToUse.content3D != null || pathToUse.content3DExtra != null) {

				if (pathToUse.content3D != null) pathToUse.content3D.setColor(color);
				if (pathToUse.content3DExtra != null) pathToUse.content3DExtra.setColor(
					color);
				pathToUse.realColor = color;
				return;

			}
			// ... but if it wasn't in the 3D viewer, recreate it:
			pathToUse.removeFrom3DViewer(univ);
			pathToUse.paths3DDisplay = paths3DDisplay;
			pathToUse.addTo3DViewer(univ, color, colorImage);
			return;
		}

		if (pathToUse.nameWhenAddedToViewer == null || !univ.contains(
			pathToUse.nameWhenAddedToViewer))
		{
			pathToUse.paths3DDisplay = paths3DDisplay;
			pathToUse.addTo3DViewer(univ, color, colorImage);
		}
	}

	synchronized public void removeFrom3DViewer(final Image3DUniverse univ) {
		if (content3D != null) {
			univ.removeContent(nameWhenAddedToViewer);
			content3D = null;
		}
		if (content3DExtra != null) {
			univ.removeContent(nameWhenAddedToViewerExtra);
			content3DExtra = null;
		}
	}

	public java.util.List<Point3f> getPoint3fList() {
		final ArrayList<Point3f> linePoints = new ArrayList<>();
		for (int i = 0; i < points; ++i) {
			linePoints.add(new Point3f((float) precise_x_positions[i],
				(float) precise_y_positions[i], (float) precise_z_positions[i]));
		}
		return linePoints;
	}

	protected boolean invalid3DMesh = false;

	private void invalidate3DView() {
		invalid3DMesh = true;
	}

	private boolean is3DViewInvalid() {
		return invalid3DMesh;
	}

	@Deprecated
	public Content addAsLinesTo3DViewer(final Image3DUniverse univ, final Color c,
		final ImagePlus colorImage)
	{
		return addAsLinesTo3DViewer(univ, new Color3f(c), colorImage);
	}

	@Deprecated
	protected Content addAsLinesTo3DViewer(final Image3DUniverse univ,
		final Color3f c, final ImagePlus colorImage)
	{
		final String safeName = univ.getSafeContentName(getName() + " as lines");
		return univ.addLineMesh(getPoint3fList(), c, safeName, true);
	}

	@Deprecated
	public Content addDiscsTo3DViewer(final Image3DUniverse univ, final Color c,
		final ImagePlus colorImage)
	{
		return addDiscsTo3DViewer(univ, new Color3f(c), colorImage);
	}

	@Deprecated
	public Content addDiscsTo3DViewer(final Image3DUniverse univ, final Color3f c,
		final ImagePlus colorImage)
	{
		if (!hasRadii()) return null;

		final Color3f[] originalColors = Pipe.getPointColors(precise_x_positions,
			precise_y_positions, precise_z_positions, c, colorImage);

		final List<Color3f> meshColors = new ArrayList<>();

		final int edges = 8;
		final List<Point3f> allTriangles = new ArrayList<>(edges * points);
		for (int i = 0; i < points; ++i) {
			final List<Point3f> discMesh = customnode.MeshMaker.createDisc(
				precise_x_positions[i], precise_y_positions[i], precise_z_positions[i],
				tangents_x[i], tangents_y[i], tangents_z[i], radii[i], 8);
			final int pointsInDiscMesh = discMesh.size();
			for (int j = 0; j < pointsInDiscMesh; ++j)
				meshColors.add(originalColors[i]);
			allTriangles.addAll(discMesh);
		}
		return univ.addTriangleMesh(allTriangles, meshColors, univ
			.getSafeContentName("Discs for path " + getName()));
	}

	@Deprecated
	synchronized public void addTo3DViewer(final Image3DUniverse univ,
		final Color c, final ImagePlus colorImage)
	{
		if (c == null) throw new IllegalArgumentException(
			"In addTo3DViewer, Color can no longer be null");
		addTo3DViewer(univ, new Color3f(c), colorImage);
	}

	@Deprecated
	synchronized public void addTo3DViewer(final Image3DUniverse univ,
		final Color3f c, final ImagePlus colorImage)
	{
		if (c == null) throw new IllegalArgumentException(
			"In addTo3DViewer, Color3f can no longer be null");

		realColor = (c == null) ? new Color3f(Color.magenta) : c;

		if (points <= 1) {
			content3D = null;
			content3DExtra = null;
			return;
		}

		if (paths3DDisplay == SNT.DISPLAY_PATHS_LINES ||
			paths3DDisplay == SNT.DISPLAY_PATHS_LINES_AND_DISCS)
		{
			content3D = addAsLinesTo3DViewer(univ, realColor, colorImage);
			content3D.setLocked(true);
			nameWhenAddedToViewer = content3D.getName();
			if (paths3DDisplay == SNT.DISPLAY_PATHS_LINES_AND_DISCS) {
				content3DExtra = addDiscsTo3DViewer(univ, realColor, colorImage);
				content3DExtraMultiColored = colorImage;
				if (content3DExtra == null) {
					nameWhenAddedToViewerExtra = null;
				}
				else {
					content3DExtra.setLocked(true);
					nameWhenAddedToViewerExtra = content3DExtra.getName();
				}
			}
			// univ.resetView();
			return;
		}

		int pointsToUse = -1;

		double[] x_points_d = new double[points];
		double[] y_points_d = new double[points];
		double[] z_points_d = new double[points];
		double[] radiuses_d = new double[points];

		if (hasRadii()) {
			int added = 0;
			int lastIndexAdded = -noMoreThanOneEvery;
			for (int i = 0; i < points; ++i) {
				if ((points <= noMoreThanOneEvery) || (i -
					lastIndexAdded >= noMoreThanOneEvery))
				{
					x_points_d[added] = precise_x_positions[i];
					y_points_d[added] = precise_y_positions[i];
					z_points_d[added] = precise_z_positions[i];
					radiuses_d[added] = radii[i];
					lastIndexAdded = i;
					++added;
				}
			}
			pointsToUse = added;
		}
		else {
			for (int i = 0; i < points; ++i) {
				x_points_d[i] = precise_x_positions[i];
				y_points_d[i] = precise_y_positions[i];
				z_points_d[i] = precise_z_positions[i];
				radiuses_d[i] = getMinimumSeparation() * 2;
			}
			pointsToUse = points;
		}

		if (pointsToUse == 2) {
			// If there are only two points, then makeTube
			// fails, so interpolate:
			final double[] x_points_d_new = new double[3];
			final double[] y_points_d_new = new double[3];
			final double[] z_points_d_new = new double[3];
			final double[] radiuses_d_new = new double[3];

			x_points_d_new[0] = x_points_d[0];
			y_points_d_new[0] = y_points_d[0];
			z_points_d_new[0] = z_points_d[0];
			radiuses_d_new[0] = radiuses_d[0];

			x_points_d_new[1] = (x_points_d[0] + x_points_d[1]) / 2;
			y_points_d_new[1] = (y_points_d[0] + y_points_d[1]) / 2;
			z_points_d_new[1] = (z_points_d[0] + z_points_d[1]) / 2;
			radiuses_d_new[1] = (radiuses_d[0] + radiuses_d[1]) / 2;

			x_points_d_new[2] = x_points_d[1];
			y_points_d_new[2] = y_points_d[1];
			z_points_d_new[2] = z_points_d[1];
			radiuses_d_new[2] = radiuses_d[1];

			x_points_d = x_points_d_new;
			y_points_d = y_points_d_new;
			z_points_d = z_points_d_new;
			radiuses_d = radiuses_d_new;

			pointsToUse = 3;
		}

		final double[] x_points_d_trimmed = new double[pointsToUse];
		final double[] y_points_d_trimmed = new double[pointsToUse];
		final double[] z_points_d_trimmed = new double[pointsToUse];
		final double[] radiuses_d_trimmed = new double[pointsToUse];

		System.arraycopy(x_points_d, 0, x_points_d_trimmed, 0, pointsToUse);
		System.arraycopy(y_points_d, 0, y_points_d_trimmed, 0, pointsToUse);
		System.arraycopy(z_points_d, 0, z_points_d_trimmed, 0, pointsToUse);
		System.arraycopy(radiuses_d, 0, radiuses_d_trimmed, 0, pointsToUse);

		/*
		 * Work out whether to resample or not. I've found that the resampling is only
		 * really required in cases where the points are at adjacent voxels. So, work
		 * out the mean distance between all the points but in image co-ordinates - if
		 * there are points only at adjacent voxels this will be between 1 and sqrt(3)
		 * ~= 1.73. However, after the "fitting" process here, we might remove many of
		 * these points, so I'll say that we won't resample if the mean is rather higher
		 * - above 3. Hopefully this is a good compromise...
		 */

		double total_length_in_image_space = 0;
		for (int i = 1; i < pointsToUse; ++i) {
			final double x_diff = (x_points_d_trimmed[i] - x_points_d_trimmed[i -
				1]) / x_spacing;
			final double y_diff = (y_points_d_trimmed[i] - y_points_d_trimmed[i -
				1]) / y_spacing;
			final double z_diff = (z_points_d_trimmed[i] - z_points_d_trimmed[i -
				1]) / z_spacing;
			total_length_in_image_space += Math.sqrt(x_diff * x_diff + y_diff *
				y_diff + z_diff * z_diff);
		}
		final double mean_inter_point_distance_in_image_space =
			total_length_in_image_space / (pointsToUse - 1);
//		SNT.log("For path " + this + ", got mean_inter_point_distance_in_image_space: "
//				+ mean_inter_point_distance_in_image_space);
		final boolean resample = mean_inter_point_distance_in_image_space < 3;

//		SNT.log("... so" + (resample ? "" : " not") + " resampling");

		final ArrayList<Color3f> tubeColors = new ArrayList<>();

		final double[][][] allPoints = Pipe.makeTube(x_points_d_trimmed,
			y_points_d_trimmed, z_points_d_trimmed, radiuses_d_trimmed, resample ? 2
				: 1, // resample - 1 means just
			// "use mean distance
			// between points", 3 is
			// three times that,
			// etc.
			12, // "parallels" (12 means cross-sections are dodecagons)
			resample, // do_resample
			realColor, colorImage, tubeColors);

		if (allPoints == null) {
			content3D = null;
			content3DExtra = null;
			return;
		}

		// Make tube adds an extra point at the beginning and end:

		final List<Color3f> vertexColorList = new ArrayList<>();
		final List<Point3f> triangles = Pipe.generateTriangles(allPoints, 1, // scale
			tubeColors, vertexColorList);

		nameWhenAddedToViewer = univ.getSafeContentName(getName());
		// univ.resetView();
		content3D = univ.addTriangleMesh(triangles, vertexColorList,
			nameWhenAddedToViewer);
		content3D.setLocked(true);
		content3DMultiColored = colorImage;

		content3DExtra = null;
		nameWhenAddedToViewerExtra = null;

		// univ.resetView();
		return;
	}

	public void setSelected(final boolean newSelectedStatus) {
		selected = newSelectedStatus;
	}

	public boolean isSelected() {
		return selected;
	}

	// TODO: this should be renamed
	public boolean versionInUse() {
		if (fittedVersionOf != null) return fittedVersionOf.useFitted;
		return !useFitted;
	}

	/**
	 * Returns an estimated volume of this path.
	 * <p>
	 * The most accurate volume of each path segment would be the volume of a
	 * convex hull of two arbitrarily oriented and sized circles in space. This is
	 * tough to work out analytically, and this precision isn't really warranted
	 * given the errors introduced in the fitting process, the tracing in the
	 * first place, etc. So, this method produces an approximate volume assuming
	 * that the volume of each of these parts is that of a truncated cone
	 * (Frustum) , with circles of the same size (i.e., as if the circles had
	 * simply been reoriented to be parallel and have a common normal vector)
	 * </p>
	 * <p>
	 * For more accurate measurements of the volumes of a neuron, you should use
	 * the filling interface.
	 * </p>
	 *
	 * @return the approximate fitted volume (in physical units), or NaN if this
	 *         Path has no radii
	 * @see #hasRadii()
	 */
	public double getApproximatedVolume() {
		if (!hasRadii()) {
			return Double.NaN;
		}

		double totalVolume = 0;
		for (int i = 0; i < points - 1; ++i) {
			final double xdiff = precise_x_positions[i + 1] - precise_x_positions[i];
			final double ydiff = precise_y_positions[i + 1] - precise_y_positions[i];
			final double zdiff = precise_z_positions[i + 1] - precise_z_positions[i];
			final double h = Math.sqrt(xdiff * xdiff + ydiff * ydiff + zdiff * zdiff);
			final double r1 = radii[i];
			final double r2 = radii[i + 1];
			// See http://en.wikipedia.org/wiki/Frustum
			final double partVolume = (Math.PI * h * (r1 * r1 + r2 * r2 + r1 * r2)) /
				3.0;
			totalVolume += partVolume;
		}

		return totalVolume;
	}

	/**
	 * Returns an estimated surface area of this path, treating each inter-node
	 * segment as a frustum.
	 *
	 * @return the approximate surface area (in physical units), or 0 if this Path
	 *         has no radii
	 * @see #hasRadii()
	 * @see #getApproximatedVolume()
	 */
	public double getApproximatedSurface() {
		if (!hasRadii()) {
			return Double.NaN;
		}

		double totalSurface = 0;
		for (int i = 0; i < points - 1; ++i) {
			final double xdiff = precise_x_positions[i + 1] - precise_x_positions[i];
			final double ydiff = precise_y_positions[i + 1] - precise_y_positions[i];
			final double zdiff = precise_z_positions[i + 1] - precise_z_positions[i];
			final double h = Math.sqrt(xdiff * xdiff + ydiff * ydiff + zdiff * zdiff);
			final double r1 = radii[i];
			final double r2 = radii[i + 1];
			// Lateral surface area of conical frustum https://en.wikipedia.org/wiki/Frustum
			final double partSurface = Math.PI * (r1 + r2) * Math.sqrt((r1 - r2) * (r1 - r2) + (h * h));
			totalSurface += partSurface;
		}

		return totalSurface;
	}
	/*
	 * This doesn't deal with the startJoins, endJoins or fitted fields, since they
	 * involve other paths which were probably also transformed by the caller.
	 */

	public Path transform(final PathTransformer transformation,
		final ImagePlus template, final ImagePlus model)
	{

		double templatePixelWidth = 1;
		double templatePixelHeight = 1;
		double templatePixelDepth = 1;
		String templateUnits = "pixels";

		final Calibration templateCalibration = template.getCalibration();
		if (templateCalibration != null) {
			templatePixelWidth = templateCalibration.pixelWidth;
			templatePixelHeight = templateCalibration.pixelHeight;
			templatePixelDepth = templateCalibration.pixelDepth;
			templateUnits = SNTUtils.getSanitizedUnit(templateCalibration.getUnit());
		}

		final Path result = new Path(templatePixelWidth, templatePixelHeight,
			templatePixelDepth, templateUnits, size());
		final double[] transformed = new double[3];

		// Actually, just say you'll have to refit all the
		// previously fitted paths...

		for (int i = 0; i < points; ++i) {
			final double original_x = precise_x_positions[i];
			final double original_y = precise_y_positions[i];
			final double original_z = precise_z_positions[i];
			transformation.transformPoint(original_x, original_y, original_z,
				transformed);
			final double new_x = transformed[0];
			final double new_y = transformed[1];
			final double new_z = transformed[2];
			if (Double.isNaN(new_x) || Double.isNaN(new_y) || Double.isNaN(new_z))
				continue;
			result.addPointDouble(new_x, new_y, new_z);
		}

		result.id = id;
		result.selected = selected;
		result.name = name;

		result.x_spacing = x_spacing;
		result.y_spacing = y_spacing;
		result.z_spacing = z_spacing;
		result.spacing_units = spacing_units;

		result.swcType = swcType;

		return result;
	}

	/**
	 * Returns the nodes which are indicated to be a join (junction/branch point),
	 * either in this Path object, or any other that starts or ends on it.
	 *
	 * @return the list of nodes as {@link PointInImage} objects
	 * @see #findJunctionIndices()
	 * @see #getJunctionNodes()
	 */
	public List<PointInImage> findJunctions() {
		final ArrayList<PointInImage> result = new ArrayList<>();
		if (startJoinsPoint != null) {
			result.add(startJoinsPoint);
		}
		for (final Path other : somehowJoins) {
			if (other.startJoins == this) {
				result.add(other.startJoinsPoint);
			}
		}
		return result;
	}

	/**
	 * This is a version of {@link #findJunctions()} ensuring that a junction node
	 * is only retrieved once even if multiple child paths are associated with it.
	 * 
	 * @see #findJunctionIndices()
	 * @return the junction nodes
	 */
	public Set<PointInImage> getJunctionNodes() {
		class LocationBasePoint extends PointInImage {
			LocationBasePoint(final PointInImage pim) {
				super(pim.x, pim.y, pim.z, pim.onPath);
				setAnnotation(pim.getAnnotation());
			}

			@Override
			public boolean equals(final Object o) {
				if (o == this) return true;
				if (o == null) return false;
				if (!(o instanceof PointInImage)) return false;
				final PointInImage other = (PointInImage) o;
				return isSameLocation(other);
			}
		}
		final Set<PointInImage> result = new HashSet<>();
		findJunctions().forEach(j -> result.add(new LocationBasePoint(j)));
		return result;
	}

	/**
	 * Returns the indices of nodes which are indicated to be a join, either in this
	 * Path object, or any other that starts or ends on it.
	 *
	 * @return the indices of junction nodes, naturally sorted
	 * @see #findJunctions()
	 * @see #getJunctionNodes()
	 */
	public TreeSet<Integer> findJunctionIndices() {
		final TreeSet<Integer> result = new TreeSet<>();
		for (final PointInImage point : findJunctions()) {
			result.add(indexNearestTo(point.x, point.y, point.z));
		}
		return result;
	}

	synchronized public void downsample(final double maximumAllowedDeviation) {
		// We should only downsample between the fixed points, i.e.
		// where this neuron joins others
		final TreeSet<Integer> fixedPoints = findJunctionIndices();
		// Add the start and end points:
		fixedPoints.add(0);
		fixedPoints.add(points - 1);
		int lastIndex = -1;
		int totalDroppedPoints = 0;
		for (final int fpi : fixedPoints) {
			if (lastIndex >= 0) {
				final int start = lastIndex - totalDroppedPoints;
				final int end = fpi - totalDroppedPoints;
				// Now downsample between those points:
				final ArrayList<SimplePoint> forDownsampling = new ArrayList<>();
				for (int i = start; i <= end; ++i) {
					forDownsampling.add(new SimplePoint(precise_x_positions[i],
						precise_y_positions[i], precise_z_positions[i], i));
				}
				final ArrayList<SimplePoint> downsampled = PathDownsampler.downsample(
					forDownsampling, maximumAllowedDeviation);

				// Now update x_points, y_points, z_points:
				final int pointsDroppedThisTime = forDownsampling.size() - downsampled
					.size();
				totalDroppedPoints += pointsDroppedThisTime;
				final int newLength = points - pointsDroppedThisTime;
				final double[] new_x_points = new double[maxPoints];
				final double[] new_y_points = new double[maxPoints];
				final double[] new_z_points = new double[maxPoints];
				// First copy the elements before 'start' verbatim:
				System.arraycopy(precise_x_positions, 0, new_x_points, 0, start);
				System.arraycopy(precise_y_positions, 0, new_y_points, 0, start);
				System.arraycopy(precise_z_positions, 0, new_z_points, 0, start);
				// Now copy in the downsampled points:
				final int downsampledLength = downsampled.size();
				for (int i = 0; i < downsampledLength; ++i) {
					final SimplePoint sp = downsampled.get(i);
					new_x_points[start + i] = sp.x;
					new_y_points[start + i] = sp.y;
					new_z_points[start + i] = sp.z;
				}
				System.arraycopy(precise_x_positions, end, new_x_points, (start +
					downsampledLength) - 1, points - end);
				System.arraycopy(precise_y_positions, end, new_y_points, (start +
					downsampledLength) - 1, points - end);
				System.arraycopy(precise_z_positions, end, new_z_points, (start +
					downsampledLength) - 1, points - end);

				double[] new_radiuses = null;
				if (hasRadii()) {
					new_radiuses = new double[maxPoints];
					System.arraycopy(radii, 0, new_radiuses, 0, start);
					for (int i = 0; i < downsampledLength; ++i) {
						final SimplePoint sp = downsampled.get(i);
						// Find a first and last index in the original radius
						// array to
						// take a mean over:
						int firstRadiusIndex, lastRadiusIndex, n = 0;
						double total = 0;
						if (i == 0) {
							// This is the first point:
							final SimplePoint spNext = downsampled.get(i + 1);
							firstRadiusIndex = sp.originalIndex;
							lastRadiusIndex = (sp.originalIndex + spNext.originalIndex) / 2;
						}
						else if (i == downsampledLength - 1) {
							// Then this is the last point:
							final SimplePoint spPrevious = downsampled.get(i - 1);
							firstRadiusIndex = (spPrevious.originalIndex + sp.originalIndex) /
								2;
							lastRadiusIndex = sp.originalIndex;
						}
						else {
							final SimplePoint spPrevious = downsampled.get(i - 1);
							final SimplePoint spNext = downsampled.get(i + 1);
							firstRadiusIndex = (sp.originalIndex + spPrevious.originalIndex) /
								2;
							lastRadiusIndex = (sp.originalIndex + spNext.originalIndex) / 2;
						}
						for (int j = firstRadiusIndex; j <= lastRadiusIndex; ++j) {
							total += radii[j];
							++n;
						}
						new_radiuses[start + i] = total / n;
					}
					System.arraycopy(radii, end, new_radiuses, (start +
						downsampledLength) - 1, points - end);
				}

				// Now update all of those fields:
				points = newLength;
				precise_x_positions = new_x_points;
				precise_y_positions = new_y_points;
				precise_z_positions = new_z_points;
				radii = new_radiuses;
				if (hasRadii()) {
					setGuessedTangents(2);
				}
			}
			lastIndex = fpi;
		}
		invalidate3DView();
	}

	/**
	 * Assigns a fixed radius to all the nodes of this Path
	 *
	 * @param r the radius to be assigned. Setting it to 0 or Double.NaN removes
	 *          the radius attribute from the Path
	 */
	public void setRadius(final double r) {
		if (Double.isNaN(r) || r == 0d) {
			radii = null;
		}
		else {
			if (radii == null) {
				createCircles();
				setGuessedTangents(2);
			}
			Arrays.fill(radii, r);
		}
	}

	public void setRadius(final double r, final int index) {
		if (Double.isNaN(r)) return;
		if (radii == null) {
			createCircles();
			setGuessedTangents(2);
		}
		radii[index] = r;
	}

	/**
	 * Assigns radii to this Path
	 *
	 * @param radii the radii array. Setting it null removes the radius attribute
	 *          from the Path
	 * @see #setRadius(double)
	 */
	public void setRadii(final double[] radii) {
		if (radii == null || radii.length == 0) {
			this.radii = null;
		}
		else if (radii != null && radii.length != size()) {
			throw new IllegalArgumentException(
				"radii array must have as many elements as nodes");
		}
		else {
			if (this.radii == null) {
				createCircles();
				setGuessedTangents(2);
			}
			System.arraycopy(radii, 0, this.radii, 0, size());
		}
	}

	public boolean isConnectedTo(final Path other) {
		return (getStartJoins() != null && getStartJoins().equals(other))
			|| (somehowJoins != null && somehowJoins.contains(other));
	}

	protected void addChangeListener(PathChangeListener listener) {
		changeListeners.add(listener);
	}

	protected boolean removeChangeListener(PathChangeListener listener) {
		return changeListeners.remove(listener);
	}

// FIXME: Implementing hasCode() and equals() breaks current TreeAnalyzer tests
//	@Override
//	public int hashCode() {
//		return Objects.hash(id, points, name, order, swcType, treeLabel);
//	}
//
//	@Override
//	public boolean equals(Object obj) {
//		if (this == obj) return true;
//		if (obj == null) return false;
//		if (getClass() != obj.getClass()) return false;
//		final Path other = (Path) obj;
//		return id == other.id && points == other.points && Objects.equals(name, other.name)
//				&& order == other.order && swcType == other.swcType && Objects.equals(treeLabel, other.treeLabel);
//	}

}
